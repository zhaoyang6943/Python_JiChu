作业：
    1. 简单描述定义一个变量x=10，在内存中的栈区、堆区的存放情况。
    （ps：垃圾回收机制。简称GC，专门回收“不可用”的变量值所占的内存。
    核心：引用计数；由此引出的“标记清除”和“分代回收”）

    答：栈区和堆区
        x  =  10，
    变量名：存的是值的内存地址；
    栈区：存放是变量名与内存地址的对应关系，所以可以简单理解为：变量名存内存地址。
    堆区：存放的是变量值

    强调：只站在变量名的角度去谈一件事情
        变量名的赋值（x=y），还有变量名的传参（print(x)），传递的都是栈区的数据，
        而且栈的数据是变量名与内存地址的对应关系，或者说是对值的引用

        python是引用传递！！！（语言）

    思考？当执行x=y，内存中的栈区和堆区变化是什么呢？
    示例1：
        x = 10
        y = 20
        x = y

    示例2：
        l = [111,222,333]
        l2 = [2222222,3333333,4444444]
        l2 = l





    2. 什么是直接引用，什么是间接引用？
    答：直接引用指的是从栈区出发直接引用到的内存地址；
    间接引用指的是从栈区出发应用到堆区后，在通过进一步引用才能到达的内存地址




    3. 简单描述python解释器垃圾回收机制的引用计数、标记清除、分代回收
    答：
    引用计数：变量值被变量名关联的次数。

    引出了问题一：循环引用
    引用计数机制存在着一个致命的弱点，既循环引用（也成交叉引用）
    # 如下我们定义了两个列表，简称列表1与列表2，变量名l1指向列表1，变量名l2指向列表2
    >>> l1=['xxx']  # 列表1被引用一次，列表1的引用计数变为1
    >>> l2=['yyy']  # 列表2被引用一次，列表2的引用计数变为1
    >>> l1.append(l2)             # 把列表2追加到l1中作为第二个元素，列表2的引用计数变为2
    >>> l2.append(l1)             # 把列表1追加到l2中作为第二个元素，列表1的引用计数变为2
    # l1与l2之间有相互引用
    # l1 = ['xxx'的内存地址,列表2的内存地址]
    # l2 = ['yyy'的内存地址,列表1的内存地址]
    >>> l1
    ['xxx', ['yyy', [...]]]
    >>> l2
    ['yyy', ['xxx', [...]]]
    >>> l1[1][1][0]
    'xxx'

    >>> del l1 # 列表1的引用计数减1，列表1的引用计数变为1
    >>> del l2 # 列表2的引用计数减1，列表2的引用计数变为1

    此时，只剩下列表1与列表2之间的相互引用
    但此时两个列表的引用计数均不为0，但两个列表不再被任何其他对象关联，没有任何人可以再引用到它们，
    所以它俩占用内存空间应该被回收，但由于相互引用的存在，每一个对象的引用计数都不为0，因此这些对
    象所占用的内存永远不会被释放，所以循环引用是致命的，这与手动进行内存管理所产生的内存泄露毫无区
    别。 所以Python引入了“标记-清除” 与“分代回收”来分别解决引用计数的循环引用与效率低的问题

    问题二：效率问题
    基于引用计数的回收机制，每次回收内存，都需要把所有对象的引用计数都遍历一遍，这是非常消耗时间的，
    于是引入了分代回收来提高回收效率，分代回收采用的是用“空间换时间”的策略。



    标记清除：是当应用程序可用的内存空间被耗尽的时候，就会停止整个程序，然后进行两项工作，
    第一项是标记，第二项是清除。

    标记：
    通俗的讲就是：栈区相当于“根”，凡是从根出发可以访问的（直接或者间接引用），都称之为“有根之人”，
    有根之人当活，无根之人当清除。
    具体的：标记的过程其实就是，遍历所有的GC Roots对象（栈区中所有的内容或者线程都可以作为GC Roots）
    然后将所有GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。

    清除：
    清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。



    分代回收：分代回收的核心思想是：在历经多次扫描的情况下，都没有被回收的变量，gc机制就会认为，
    该变量是常用变量，gc对其扫描的频率会降低，

    具体的：分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）。新定义的变量，放到新生代这个等级中，
    假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的
    权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间
    隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，
    青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低。




    4. 写一段程序
        接收用户输入的用户名、年龄、性别，然后选取最优格式化字符串的方式
        格式输出

        我的名字是：xxx
        我的年龄是：xxx
        我的性别是：xxx

        格式化输出
        %
        str.format()
        f''



    5. 算术运算符相关
        /
        //
        用示例演示
            取模运算
            增量赋值
                age+=1 # age = age+1
            交叉赋值
                x,y=y,x
            链式赋值
                x,y,z=10
            解压赋值
                x,y,*_,z=[10,20,30,40,50]
